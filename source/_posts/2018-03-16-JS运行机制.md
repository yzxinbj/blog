---
title: JS运行机制
date: 2018-03-16 10:17:37
tags: JS
categories: 编程
---

### 浏览器进程
- 进程？
系统独立分配的一块内存，是 cpu 资源分配的最小单位
- 线程？
是 cpu 最小的调度单位，是在进程基础上的一次程序运行单位

- 浏览器都包含哪些进程？
1. Browser进程: Browser 主进程主控，协调每个 Tab 页，每个 tab 又是一个独立的进程
2. 浏览器渲染进程（Renderer进程，即每个 Tab 进程）
3. GPU进程（最多一个，用于3D 绘制）
4. 第三方插件进程


- 重点浏览器内核（渲染进程，Renderer进程，即每个 tab 页）
在浏览器中打开一个网页相当于新启一个进程，此进程又包含5个线程  
（多个 tab 空白页可能会被优化为一个进程）

- 哪五个线程？
1. GUI 渲染线程：
2. JS 引擎线程：
3. 事件触发线程：
4. 定时触发器线程：
5. 网络请求线程：可以理解为异步 http 请求线程

GUI 线程与 JS线程互斥：为了防止两个线程同时改变视图，引发矛盾


### 浏览器内核运行
1. 输入一个 url 请求通过下载线程，获取返回结果，然后RendererHost交个 Renderer 进程
2. Renderer 进程解析 html css ==>> render 树   交给GPU
3. 触发 DOMContentLoaded && load 事件 (区别：通过事件定义可以区分，DOMContentLoaded是dom加载完成，而 load 是渲染完成)


### JS引擎单线程 

- webworker
js 向 浏览器申请的一个子线程，完全受js主线程控制，且不能操作 dom
且需要通过特定的序列化接口通信

### JS事件循环机制
事件，定时器都是通过回调，然后排队
而promise 可以理解为插队，是放到 microTask 队列中，在 macroTask 之前



了解了浏览器模型
那就可以解释为什么 js会阻塞页面加载？
由于渲染页面的 GUI线程互斥与 JS线程，就会导致 GUI任务需要排队等待的情况


## 展开——浏览器访问一个地址（url）到底发生了什么？










