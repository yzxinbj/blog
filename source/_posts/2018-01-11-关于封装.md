---
title: 关于封装
date: 2018-01-11 15:01:53
tags: js object
categories: 编程
---

## 对象封装
### 什么是对象？
> 对象：无序属性的集合，其属性可以包含基本值，对象或者函数


### 创建对象的方法有多少种？

- var obj = {}; // 字面量
- var obj = new Object(); // new


### 封装对象的目的是什么？
- 隐藏细节实现，开放接口调用
- 复用，使逻辑清晰，代码好维护


### 怎么封装？

#### 原型链?

```javascript
// 工厂模式
function createPoint(x, y){
    var point = new Object();
    
    point.x = x;
    point.y = y;
    
    point.getX = function(){
        return x;
    };
    
    point.getY = function(){
            return y;
    };
    
    return point;
}

// 工厂模式没有解决识别对象的问题，故又发展出构造函数模式
// 构造函数模式
function Point(x, y){
    this.x = x;
    this.y = y;
    
    this.getX = function() {
         return this.x;
    };
    
    this.getY = function(){
        return this.y;
    };
}

var point = new Point(1, 2);
point instanceof Point; // true

// 构造函数模式并没有解决重复在实例上有重复方法的问题，如每个实例都有一个 getX ,getY 方法
// 故原型模式，建立公私有属性或方法，解决👆这个问题
function Point(x, y){
    this.x = x;
    this.y = y;
}

Point.prototype.getX = function(){
    return this.x;
};
Point.prototype.getY = function(){
    return this.y;
};
// 或者
Point.protoType = {
    getX: function(){
        return this.x;
    },
    getY: function(){
       return this.y;
    },
    // 注意这种方式必须要加 constructor, 因为 {} 表示一个新的对象，其中并不包含 constructor 
    constructor: Point
};

```
> 注：加 constructor 的情况要记住, 因为 {} 表示一个新的对象，其中并不包含 constructor 

#### 继承?
1. 原型继承
```javascript
function SuperType(){
    this.a = false;
}
SuperType.prototype.getA = function(){
    return this.a;
};

function SubType(){
    this.b = true;
};

SubType.prototype = new SuperType();

var instance = new SubType();

```

2. call 继承，借用构造函数
```javascript
function SuperType(x, y){
    this.x = x;
    this.y = y;
}

function SubType(x, y, z){
    SuperType.call(this, x, y);
    this.z = z;
}
```

3. 组合继承
```javascript
function SuperType(x, y){
    this.x = x;
    this.y = y;
}

SuperType.prototype.getX = function(){
    return this.x;
}

function SubType(x, y, z){
    SuperType.call(this, x, y);
    this.z = z;
}

// 结合 call 继承多了下面这两行
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.getZ = function(){
    return this.z;
};
```


4. 寄生组合继承
```javascript
function SuperType(x, y){
    this.x = x;
    this.y = y;
}

SuperType.prototype.getX = function(){
    return this.x;
}

function SubType(x, y, z){
    SuperType.call(this, x, y);
    this.z = z;
}

function object(o){
    function F(){}
    F.prototype=o;
    return new F();
}

// 下面这三行是重点
var prototype = object(SuperType.prototype);
prototype.constructor = SubType;
SubType.prototype = prototype;

SubType.prototype.getZ = function(){
    return this.z;
};
```

5. ES6的类继承

#### new?

```javascript
function Base(name, age){
    this.name = name;
    this.age = age;
}

var obj = new Base();

// new 等价于
var obj = {};
obj.__proto__ = Base.prototype;
Base.call(obj, name, age);

obj instanceof Base // true

```

