---
title: 关于Promise
date: 2018-03-10 11:47:36
tags:
categories:
---

### Promise规范
Promise 的规范有很多种： Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+

[石墨文档翻译的Promise/A+规范](http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/)

### Promise 本质是一个状态机
then 实际上就是：如果已经 resolve ，如果当前 promise 实例 已经有了结果，则直接调用对应的成功或失败回调，如果没有结果，则把回调先绑定到当前实例上

resolve 就是给 promise实例 绑定一个结果，并且如果已经调用 then 绑定了成功和失败的回调，则执行对应回调，否则不执行；

### 自己的理解
Promise 内部通过
1. 局部变量暂存：异步返回的结果、成功失败的回调函数（resolve, reject，类似观察者模式）
2. Promise 接受一个回调函数，通过给此回调函数传入 resolve ,reject 函数来控制
 
Promise 内通过异步执行resolve,reject回调,来保证 then 函数在其之前执行，并且在 then 函数中通过状态变量来控制，是否执行回调还是暂存回调（观察者）


简版 promise 分析理解
```javascript
function Promise(fn) {
    var state = 'pending',      // 状态控制
        value = null,           // 暂存返回值
        callbacks = [];         // 暂时存储回调
    
    this.then = function (onFulfilled) {
        if (state === 'pending') {             // 判断是否得到结果，是执行还是暂存
            callbacks.push(onFulfilled);
            return this;
        }
        onFulfilled(value);
        return this;
    };
    
    function resolve(newValue) {
        setTimeout(function () {               // 异步执行
            value = newValue;                  // 暂存结果
            state = 'fulfilled';               // 得到结果， 更改状态
            
            callbacks.forEach(function (callback) {
                callback(value);
            });
        }, 0);
    }
    
    fn(resolve);                              // 执行 Promise 传入的回调，最先执行，传入 resolve ，方便自定义何时执行返回结果
}
```

```javascript
function Promise(fn){
  var status = 'pending',
      callbacks = [],
      value;
  
  var resolve = function(val){
    // 1. 存下返回的值&改变状态
    value = val;
    status = 'fulfilled';
    
    // 2. 执行 callbacks 里的回调，如果没有调用了 then 则 callbacks 为空
      // 增加判断
    callbacks.length && callbacks.forEach(function (cb) {
        cb(value);
    });
    
  };
  
  var reject = function(){
    // 1. 改变状态
    status = 'rejected';
    
  };
  
  this.then = function(onFulfilled, onRejected){
    // 1. 判断状态，如果 fullfilled  则表示返回了结果，则立即执行onFulfilled成功回调，否则，暂时存入 callbacks 里，等待返回结果后被resolve函数内调用
    if(status === 'fulfilled'){
      // 此处判断不严谨，暂时只做简单判断
      onFulfilled && onFulfilled(value);
      return ;
    } 
    
    if(status === 'rejected') {
      onRejected && onRejected(value);
      return ;
    }
    
    callbacks.push(onFulfilled);
  }
  
  // 去掉了类型判断
  fn(resolve);
  
  
  
}
```

## 知识点

1. 
```ecmascript 6
const p1 = new Promise(function (resolve, reject) {
  // ...
});

const p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
  // 相当于p1执行 then , 但接受的回调函数是 p2的， 知识点！！
  p1.then(p2.resolvingFunctions[0],p2.resolvingFunctions[1]);
})
```


2. 
```ecmascript 6
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
```
输出是？ 2, 1

好的方法，添加 return
```ecmascript 6
new Promise((resolve, reject) => {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
```
3. 

